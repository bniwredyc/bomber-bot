<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>hello phaser!</title>
        <script src="/bomberman/lib/phaser.min.js"></script>
    </head>
    <body>

    <script type="text/javascript">

    var WALL = 100;
    var MAP = [
        [WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL],
        [WALL, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  WALL],
        [WALL, 0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,  WALL],
        [WALL, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  WALL],
        [WALL, 0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,  WALL],
        [WALL, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  WALL],
        [WALL, 0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,  WALL],
        [WALL, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  WALL],
        [WALL, 0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,   WALL,0,  WALL],
        [WALL, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  WALL],
        [WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL,WALL]
        // [WALL, 0,   WALL,WALL,WALL,0,   WALL,WALL,WALL,0,   WALL,WALL,WALL,0,  WALL],
        // [WALL, 0,   WALL,0,   WALL,0,   0,   WALL,0,   0,   0,   WALL,0,   0,  WALL],
        // [WALL, 0,   WALL,0,   WALL,0,   0,   WALL,0,   0,   0,   WALL,0,   0,  WALL],
        // [WALL, 0,   WALL,0,   WALL,0,   0,   WALL,0,   0,   0,   WALL,0,   0,  WALL],
        // [WALL, 0,   WALL,WALL,WALL,0,   0,   WALL,0,   0,   0,   WALL,0,   0,  WALL],
    ];

    var SPACE = {
        X: 60,
        Y: 60
    };

    function getRoundedX(x){
        return Math.floor(x / SPACE.X)*SPACE.X;
    }
    function getRoundedY(y){
        return Math.floor(y / SPACE.Y)*SPACE.Y;
    }
    function getMapX(x){
        if (!x) { return 0; }
        return Math.floor(x / SPACE.X);
    }
    function getMapY(y){
        if (!y) { return 0; }
        return Math.floor(y / SPACE.Y);
    }

    function makeBomb (player, map) {
        var game = player.game;
        var bomb = new Phaser.Group(game);

        bomb.position.x = getRoundedX(player.body.x);
        bomb.position.y = getRoundedY(player.body.y);

        var map_x = getMapX(bomb.position.x);
        var map_y = getMapY(bomb.position.y);
        var barrier = {
            up: false, down: false, left: false, right: false
        };

        if (map(map_x, map_y + 1) > 0) {
            barrier.down = true;
        }
        if (map(map_x, map_y - 1) > 0) {
            barrier.up = true;
        }
        if (map(map_x - 1, map_y) > 0) {
            barrier.left = true;
        }
        if (map(map_x + 1, map_y) > 0) {
            barrier.right = true;
        }

        // bomb center
        var center = game.add.sprite(0, 0, 'bomb', 30);
        game.physics.arcade.enable(center);
        center.body.immovable = true;
        bomb.add(center);

        center.animations
            .add('moving',
                [ 30, 29, 28, 29, 30, 29, 28, 29, 30, 29, 28, 29, 30, 29, 28, 29, 30 ], 10, false)
            .play()
            .onComplete.add(function(){
                center.kill();
                game.add.sound('explode').play();

                // bomb flames
                var flame_center = game.add.sprite(0, 0, 'flames', 34);
                flame_center.animations
                    .add('explosion', [ 0, 1, 2, 3, 2, 1, 0 ], 10, false)
                    .play()
                    .onComplete.add(function(){
                        bomb.alive = false;
                        bomb.destroy();
                    });
                bomb.add(flame_center);

                if (!barrier.right) {
                    var flame_right = game.add.sprite(0, 0, 'flames', 34);
                    flame_right.position.x = SPACE.X;
                    flame_right.animations
                        .add('explosion', [16, 17, 18, 19, 18, 17, 16], 10, false)
                        .play();

                    bomb.add(flame_right);
                }
                if (!barrier.left) {
                    var flame_left = game.add.sprite(0, 0, 'flames', 34);
                    flame_left.position.x = -SPACE.Y;
                    flame_left.animations
                        .add('explosion', [4, 5, 6, 7, 6, 5, 4], 10, false)
                        .play();

                    bomb.add(flame_left);
                }
                if (!barrier.up) {
                    var flame_up = game.add.sprite(0, 0, 'flames', 34);
                    flame_up.position.y = -SPACE.Y;
                    flame_up.animations
                        .add('explosion', [12, 13, 14, 15, 14, 13, 12], 10, false)
                        .play();

                    bomb.add(flame_up);
                }
                if (!barrier.down) {
                    var flame_down = game.add.sprite(0, 0, 'flames', 34);
                    flame_down.position.y = SPACE.Y;
                    flame_down.animations
                        .add('explosion', [24, 25, 26, 27, 26, 25, 24], 10, false)
                        .play();
                    bomb.add(flame_down);
                }

                game.physics.arcade.enable(bomb);
                bomb.setAll('body.immovable', true);
            });

        return bomb;
    }

    function touchingBomb(player, sprite) {
        if(player.dead){
            return;
        }

        if(sprite.key == 'flames'){
            player.animations
                .play('die')
                .onComplete.add(function () {
                    player.kill();
                });

            player.game.sound.add('hurt').play();
            player.dead = true;
        }
    }

    function getRandomBrickNum() {
        var walls = [1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27];
        return walls[ Math.floor(Math.random()*(walls.length - 1)) ];
    }

    function makeBricks(game) {
        var bricks = new Phaser.Group(game);

        for (var Y in MAP){
            for (var X in MAP[Y]){
                if(MAP[Y][X] === WALL){
                    bricks.add(
                        game.add.sprite(
                            X*SPACE.X,
                            Y*SPACE.Y,
                            'bricks',
                            getRandomBrickNum()
                        )
                    );
                }
            }
        }

        game.physics.arcade.enable(bricks);
        bricks.setAll('body.immovable', true);
        return bricks;
    };

    function chooseRandomPoint(map){
        var y = Math.floor(Math.random() * (map.height - 0.01));
        var x = Math.floor(Math.random() * (map.width - 0.01));
        if(map(x, y) > 0){
            return chooseRandomPoint(map);
        }
        return { x: x, y: y };
    }

    function dumpPlayer(my_info, my_state, map, info_objects) {
        var x = Math.floor(my_info.x());
        var y = Math.floor(my_info.y());

        for(var p in info_objects){
            var obj = info_objects[p];
            if(obj.type() !== 'player' ){
                continue;
            }
            if(obj.id() === my_info.id()){
                continue; // myself
            }

            // place bomb if enemi is near
            if(Math.abs(obj.x() - x) < 3 && Math.abs(obj.y() - y) < 3){
                if(my_state.bomb === undefined || my_state.bomb < Date.now() ){
                    my_state.bomb = Date.now() + 1000;
                    return 'bomb';
                }
            }
        }

        if(my_state.x === undefined || (my_state.x == x && my_state.y == y)){
            var p = chooseRandomPoint(map);
            my_state.x = p.x;
            my_state.y = p.y;
            my_state.y_priority = false
        }

        var distance_x = my_state.x - x;
        var distance_y = my_state.y - y;

        if (!my_state.y_priority && distance_x > 0) {
            if (map(x + 1, y) > 0) {
                if (map(x, y + 1) <= 0) {
                    return 'down';
                }
                else {
                    return 'up';
                }
            }
            return 'right';
        }
        else if (!my_state.y_priority && distance_x < 0) {
            if (map(x - 1, y) > 0) {
                if (map(x, y + 1) <= 0) {
                    return 'down';
                }
                else {
                    return 'up';
                }
            }
            return 'left';
        }
        else if (distance_y < 0) {
            if (map(x, y - 1) > 0) {
                if (map(x + 1, y) <= 0) {
                    my_state.y_priority = true;
                    return 'right';
                }
                else {
                    my_state.y_priority = true;
                    return 'left';
                }
            }
            return 'up';
        }
        else if (distance_y > 0) {
            if (map(x, y + 1) > 0) {
                if (map(x + 1, y) <= 0) {
                    my_state.y_priority = true;
                    return 'right';
                }
                else {
                    my_state.y_priority = true;
                    return 'left';
                }
            }
            return 'down';
        }
        else if (distance_x > 0) {
            my_state.y_priority = false;
            return 'right';
        }
        else if (distance_x < 0) {
            my_state.y_priority = false;
            return 'left';
        }
        else {
            my_state.y_priority = false;
        }

        return 'stop';
    }

    function Player(id, game, x, y, controller){
        var phaserPlayer = game.add.sprite(x*SPACE.X, y*SPACE.Y, 'dude', 4);
        game.physics.arcade.enable(phaserPlayer);
        //  Player physics properties. Give the little guy a slight bounce.
        phaserPlayer.body.collideWorldBounds = true;

        phaserPlayer.animations.add('left', [0, 1, 2],  10, true);
        phaserPlayer.animations.add('right',[9, 10, 11],10, true);
        phaserPlayer.animations.add('up',   [6, 7, 8],  10, true);
        phaserPlayer.animations.add('down', [3, 4, 5],  10, true);
        phaserPlayer.animations.add('die',  [12, 13, 14, 15 ,16, 17, 18], 10, false);

        var self = this;
        self.id = id;
        self.pp = phaserPlayer;
        self.state = new (function PlayerInternalState(){})();
        self.info = new (function PlayerPublicInfo() {
            // defined as function for not let other players to overwrite data
            this.type = function() { return 'player'; };
            this.id = function() { return self.id; };
            this.x = function() { return self.x; };
            this.y = function() { return self.y; };
            this.lastAction = function(){ return self.lastAction; } ;
        })();
        self.map = function(x, y) {
            // defined as function for not let other players to overwrite data
            if(MAP[y] === undefined){ return WALL; }
            if(MAP[y][x] === undefined){ return WALL; }
            return MAP[y][x];
        };
        self.map.width = MAP[0].length;
        self.map.height = MAP.length;
        self.controller = controller;
        self.lastSetBomb = 0;
    };

    window.onload = function() {
        var width  = (MAP[0].length) * SPACE.X;
        var height = (MAP.length) * SPACE.Y;
        var game   = new Phaser.Game(width, height, Phaser.AUTO, '',
                                     { preload: preload, create: create, update: update });

        destroy = function (){
            game.destroy();
        }

        var cursors;
        var player;
        var pause = 0;
        var bombs = [];
        var players = [];
        var info_objects = [];
        var bricks;

        function preload () {
            game.load.spritesheet('dude', '/bomberman/sprites/bomberman.png', 40, 60);
            game.load.spritesheet('bomb', '/bomberman/sprites/bomb2.png', 60, 60);
            game.load.spritesheet('flames', '/bomberman/sprites/bomb2.png', 60, 60);
            game.load.spritesheet('bricks', '/bomberman/sprites/bricks.png', 60, 60);
            game.load.audiosprite('explode', '/bomberman/sounds/explosion_15.mp3');
            game.load.audiosprite('hurt', '/bomberman/sounds/hurt1.mp3');
        }

        function create () {
            cursors = game.input.keyboard.createCursorKeys();
            cursors.space = game.input.keyboard.addKeys({ space: Phaser.KeyCode.SPACEBAR}).space;
            game.physics.startSystem(Phaser.Physics.ARCADE);

            bricks = makeBricks(game);
            // players.push(new Player(0, game, 1, 1, dumpPlayer));
            var spawn_points = [
                [1,1],
                [MAP[0].length - 2, 1],
                [1, MAP.length - 2],
                [MAP[0].length - 2, MAP.length - 2]
            ];

            for(var i = 0; i < 4; i++){
                var plr = new Player(i, game,
                                     spawn_points[i%spawn_points.length][0],
                                     spawn_points[i%spawn_points.length][1],
                                     dumpPlayer);
                players.push(plr);
                info_objects.push(plr.info);
            }

            // debug:
            p = players;
            pp = info_objects;
        }

        function updatePlayer(player) {
            game.physics.arcade.collide(player.pp, bricks);
            game.physics.arcade.overlap(player.pp, bombs, touchingBomb);

            // run once
            if(player.pp.dead){
                player.pp.body.velocity.x = 0;
                player.pp.body.velocity.y = 0;
                return;
            }

            player.x = player.pp.body.x / SPACE.X;
            player.y = player.pp.body.y / SPACE.Y;

            var newAction = player.controller(
                                player.info,
                                player.state,
                                player.map,
                                info_objects
                            );

            if (!newAction || newAction === 'stop') {
                player.pp.body.velocity.x = 0;
                player.pp.body.velocity.y = 0;
                player.pp.animations.stop();
                player.pp.frame = 4;
                return;
            }

            if (newAction == 'bomb') {
                if(Date.now() - player.lastSetBomb > 1000) {
                    bombs.push(makeBomb(player.pp, player.map));
                    player.lastSetBomb = Date.now();
                }
                return;
            }

            // finish movement before direction change
            if ((player.lastAction === 'left' || player.lastAction === 'right') &&
                (newAction === 'up' || newAction === 'down')) {
                    if((player.pp.body.x % SPACE.X) != 0){
                        return;
                    }
            }
            else if ((player.lastAction === 'up' || player.lastAction === 'down') &&
                (newAction === 'left' || newAction === 'right')) {
                    if((player.pp.body.y % SPACE.Y) != 0){
                        return;
                    }
            }

            //  Reset the players velocity (movement)
            player.pp.body.velocity.x = 0;
            player.pp.body.velocity.y = 0;

            if (newAction === 'right') {
                player.pp.body.velocity.x = 150;
                player.pp.animations.play('right');
            }
            else if (newAction === 'left') {
                player.pp.body.velocity.x = -150;
                player.pp.animations.play('left');
            }
            else if (newAction === 'down') {
                player.pp.body.velocity.y = 150;
                player.pp.animations.play('down');
            }
            else if (newAction === 'up') {
                player.pp.body.velocity.y = -150;
                player.pp.animations.play('up');
            }
            else {
                player.pp.animations.stop();
                player.pp.frame = 4;
            }

            // direction change helper
            player.lastAction = newAction;
        }
        // TODO:
        // big bombs
        // game finish
        function update () {
            if(players.length <= 1){
                // the winner is...
            }

            for (var idx in players) {
                var player = players[idx]
                updatePlayer(player);

                // remove dead players
                if (player.pp.dead) {
                    players.splice(idx, 1);
                    for(var id in info_objects){
                        if (info_objects[id].type() === 'player' &&
                            info_objects[id].id() == player.id) {
                                info_objects.splice(id, 1);
                        }
                    }
                }
            }
        }

    };

    </script>

    </body>
</html>